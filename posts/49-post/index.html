<!DOCTYPE html>
<html class="dark light">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    

    
    
    
    <title>
         49. Making my own Teeny Tiny Compiler - Lexer
        
    </title>

        
            <meta property="og:title" content="49. Making my own Teeny Tiny Compiler - Lexer" />
        
     

     
         
     

     
         
    

    
    <link rel="icon" type="image/png" href=&#x2F;icons&#x2F;icon.png />

    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">

    
    
        <link href=https://harsh-doshii.github.io/fonts.css rel="stylesheet" />
    

    
    


    

    
    <link rel="alternate" type="application/atom+xml" title="doshi&#x27;s scratchpad" href="https://harsh-doshii.github.io/atom.xml">


    
    
        <link rel="stylesheet" type="text/css" href=https://harsh-doshii.github.io/theme/light.css />
        <link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://harsh-doshii.github.io/theme/dark.css" />
    

    <link rel="stylesheet" type="text/css" media="screen" href=https://harsh-doshii.github.io/main.css />

    

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170818569-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-170818569-1');
    </script>

    <script async src="https://us.umami.is/script.js" data-website-id="2b0e0e64-98d6-464b-8574-2cb94d848738"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>
</head>

<body>
    <div class="content">
        <header>
    <div class="main">
        <a href=https:&#x2F;&#x2F;harsh-doshii.github.io&#x2F;>doshi&#x27;s scratchpad</a>

        <div class="socials">
            
            <a rel="me" href="https:&#x2F;&#x2F;discuss.systems&#x2F;@hdoshi" class="social">
                <img alt=mastodon src="/social_icons/mastodon.svg">
            </a>
            
            <a rel="me" href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;harsh-doshi16&#x2F;" class="social">
                <img alt=linkedin src="/social_icons/linkedin.svg">
            </a>
            
            <a rel="me" href="https:&#x2F;&#x2F;github.com&#x2F;harsh-doshii" class="social">
                <img alt=github src="/social_icons/github.svg">
            </a>
            
        </div>
    </div>

    <nav>
        
        <a href=&#x2F;posts style="margin-left: 0.7em">&#x2F;posts</a>
        
        <a href=&#x2F;about style="margin-left: 0.7em">&#x2F;about</a>
        
        <a href=&#x2F;people style="margin-left: 0.7em">&#x2F;people</a>
        
        <a href=&#x2F;recommendations style="margin-left: 0.7em">&#x2F;recommendations</a>
        

        
        | <a id="dark-mode-toggle" onclick="toggleTheme()" href="javascript:void(0)">
            <img src="/feather/sun.svg" id="sun-icon" style="filter: invert(1);" />
            <img src="/feather/moon.svg" id="moon-icon" />
        </a>
        <script src=https://harsh-doshii.github.io/js/themetoggle.js></script>
        
    </nav>
</header>


        
        
    
<main>
    <article>
        <div class="title">
            
            
    <div class="page-header">
        49. Making my own Teeny Tiny Compiler - Lexer<span class="primary-color" style="font-size: 1.6em">.</span>
    </div>


                <div class="meta">
                    
                        Posted on <time>2023-12-18</time>
                    

                    
                </div>
        </div>

        

        
        
            
        

        <section class="body">
            <p>I am following this article: <a href="https://austinhenley.com/blog/teenytinycompiler1.html">Let's make a Teeny Tiny compiler, part 1</a> by the very amazing Austin Henley. This blog is placeholder for my notes that I am making while I go follow Austin's article.</p>
<p>A compiler basically has the following flow:
source code --&gt; lexer (gives tokens) --&gt; parser (gives program tree) --&gt; emitter (gives compiled code)</p>
<p>Let's start with the lexer!
Functionality: Given a string of Teeny Tiny code, it will iterate character by character to do two things: decide where each token starts/stops and what type of token it is. If the lexer is unable to do this, then it will report an error for an invalid token.</p>
<p>Steps on building the lexer:</p>
<ol>
<li>First we gathered the functions that we need: nextChar, peek, skipWhitespace, skipComment, abort and getToken</li>
<li>We defined class Token which has two attributes: tokenChar and tokenKind. tokenKind is an enum.</li>
<li>First we wrote the lexing logic for single operators like +,=, whitespace etc. Then extended this to two char operators like '==' using peek function.</li>
<li>Then we extended the logic to identify Strings, Comments, Numbers, Identifiers and Keywords</li>
</ol>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import enum
import sys

class Lexer:
    def __init__(self, source):
        pass

    #Process the next character
    def nextChar(self):
        self.curPos += 1
        if self.curPos &gt;= len(self.source):
            self.curChar = &#x27;\0&#x27;  # EOF (End of file)
        else:
            self.curChar = self.source[self.curPos]

    #Return the lookahead character
    def peek(self):
        if(self.curPos + 1 &gt;= len(self.source)):
            return &#x27;\0&#x27;
        else:
            return self.source[self.curPos+1]

    #Invalid token found, print error message and exit
    def abort(self, message):
        sys.exit(&quot;Lexing error. &quot; + message)


    #Skip whitespace except newline which indicates end of line
    def skipWhitespace(self):
        while self.curChar == &#x27; &#x27; or self.curChar == &#x27;\t&#x27; or self.curChar == &#x27;\r&#x27;:
            self.nextChar()

    #Ignore comments
    def skipComment(self):
        if self.curChar == &#x27;#&#x27;:
            while self.curChar != &#x27;\n&#x27;:
                self.nextChar()


    #Retrun the next token
    def getToken(self):
        token = None
        # Check the first character of this token to see if we can decide what it is.
        # If it is a multiple character operator (e.g., !=), number, identifier, or keyword then we will process the rest.
        self.skipWhitespace()
        self.skipComment()
        if self.curChar == &#x27;+&#x27;:
            token = Token(self.curChar, TokenType.PLUS)
        elif self.curChar == &#x27;-&#x27;:
            token = Token(self.curChar, TokenType.MINUS)
        elif self.curChar == &#x27;*&#x27;:
            token = Token(self.curChar, TokenType.ASTERISK)
        elif self.curChar == &#x27;&#x2F;&#x27;:
            token = Token(self.curChar, TokenType.SLASH)
        elif self.curChar == &#x27;=&#x27;:
            if self.peek() == &#x27;=&#x27;:
                lastChar = self.curChar
                self.nextChar()
                token = Token(lastChar + self.curChar, TokenType.EQEQ)
            else:
                token = Token(self.curChar, TokenType.EQ)
        elif self.curChar == &#x27;&gt;&#x27;:
            if self.peek() == &#x27;=&#x27;:
                lastChar = self.curChar
                self.nextChar()
                token = Token(lastChar + self.curChar, TokenType.GTEQ)
            else:
                token = Token(self.curChar, TokenType.GT)
        elif self.curChar == &#x27;&lt;&#x27;:
            if self.peek() == &#x27;=&#x27;:
                lastChar = self.curChar
                self.nextChar()
                token = Token(lastChar + self.curChar, TokenType.LTEQ)
            else:
                token = Token(self.curChar, TokenType.LT)
        elif self.curChar == &#x27;!&#x27;:
            if self.peek() == &#x27;=&#x27;:
                lastChar = self.curChar
                self.nextChar()
                token = Token(lastChar + self.curChar, TokenType.NOTEQ)
            else:
                self.abort(f&quot;Expected &#x27;!=&#x27; got !{self.peek()}&quot;)
        elif self.curChar == &#x27;\n&#x27;:
            token = Token(self.curChar, TokenType.NEWLINE)
        elif self.curChar == &#x27;\0&#x27;:
            token = Token(&#x27;&#x27;, TokenType.EOF)
        elif self.curChar == &#x27;\&quot;&#x27;:
            self.nextChar()
            startPos = self.curPos
            while self.curChar != &#x27;\&quot;&#x27;:
                if self.curChar == &#x27;\r&#x27; or self.curChar == &#x27;\n&#x27; or self.curChar == &#x27;\t&#x27; or self.curChar == &#x27;\\&#x27; or self.curChar == &#x27;%&#x27;:
                    self.abort(&quot;Illegal character in string.&quot;)
                self.nextChar()
            tokText = self.source[startPos:self.curPos]
            token = Token(tokText, TokenType.STRING)
        elif self.curChar.isdigit():
            # Leading character is a digit, so this must be a number.
            # Get all consecutive digits and decimal if there is one.
            startPos = self.curPos
            while self.peek().isdigit():
                self.nextChar()
            if self.peek() == &#x27;.&#x27;: # Decimal!
                self.nextChar()

                # Must have at least one digit after decimal.
                if not self.peek().isdigit(): 
                    # Error!
                    self.abort(&quot;Illegal character in number.&quot;)
                while self.peek().isdigit():
                    self.nextChar()

            tokText = self.source[startPos : self.curPos + 1] # Get the substring.
            token = Token(tokText, TokenType.NUMBER)
        elif self.curChar.isalpha():
            # Leading character is a letter, so this must be an identifier or a keyword.
            # Get all consecutive alpha numeric characters.
            startPos = self.curPos
            while self.peek().isalnum():
                self.nextChar()

            # Check if the token is in the list of keywords.
            tokText = self.source[startPos : self.curPos + 1] # Get the substring.
            keyword = Token.checkIfKeyword(tokText)
            if keyword == None: # Identifier
                token = Token(tokText, TokenType.IDENT)
            else:   # Keyword
                token = Token(tokText, keyword)
        else:
            # Unknown token!
            self.abort(&quot;Unkown token: &quot; + self.curChar)

        self.nextChar()
        return token

    #Constructor
    def __init__(self, source):
        self.source = source + &#x27;\n&#x27; # Source is basically the Source code to lex as a string. Append a newline to simplify lexing&#x2F;parsing the last token&#x2F;statement.
        self.curChar = &#x27;&#x27;   # Current character in the string.
        self.curPos = -1    # Current position in the string.
        self.nextChar()

class Token:
    def __init__(self, tokenText, tokenKind):
        self.text = tokenText   # The token&#x27;s actual text. Used for identifiers, strings, and numbers.
        self.kind = tokenKind   # The TokenType that this token is classified as.
    @staticmethod
    def checkIfKeyword(tokenText):
        for kind in TokenType:
            # Relies on all keyword enum values being 1XX.
            if kind.name == tokenText and kind.value &gt;= 100 and kind.value &lt; 200:
                return kind
        return None
# TokenType is our enum for all the types of tokens.
class TokenType(enum.Enum):
    EOF = -1
    NEWLINE = 0
    NUMBER = 1
    IDENT = 2
    STRING = 3 
    # Keywords.
    LABEL = 101
    GOTO = 102
    PRINT = 103
    INPUT = 104
    LET = 105
    IF = 106
    THEN = 107
    ENDIF = 108
    WHILE = 109
    REPEAT = 110
    ENDWHILE = 111
    # Operators.
    EQ = 201  
    PLUS = 202
    MINUS = 203
    ASTERISK = 204
    SLASH = 205
    EQEQ = 206
    NOTEQ = 207
    LT = 208
    LTEQ = 209
    GT = 210
    GTEQ = 211    
</code></pre>
<p>With this the lexer is completed!!</p>

        </section>

        

    </article>
</main>


    </div>
</body>

</html>